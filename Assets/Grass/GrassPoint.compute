// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FindGrassPoints

#include "Simplex.compute"
#include "UnityCG.cginc"
#include "Scale.compute"

// Struct for GrassData with position and UV's
struct GrassData {
    float4 position;
    float2 uv;
    float displacement;
    bool placePosition;
};

// Initialize variables
RWStructuredBuffer<GrassData> _GrassBuffer;
RWTexture2D<float4> _PlacementMap;
RWTexture2D<float4> _HeightMap;

float3 _TerrainPosition;
float2 _Resolution;
float _MaxTerrainHeight, _Scale, _MeshHeight;

int _HeightMapRes, _TerrainDim, _XOffset, _YOffset, _NumChunks, _ChunkDimension;

float2 Rotate(float2 input, float angle) {
    float c = cos(angle * ((UNITY_PI * 2)/360));
    float s = sin(angle * ((UNITY_PI * 2)/360));
    return float2(
        input.x * c - input.y * s,
        input.x * s + input.y * c);
}

// 8x8x1 threads which makes for optimal 64 threads
[numthreads(8, 8, 1)]
void FindGrassPoints (uint3 id : SV_DispatchThreadID)
{
    // Check if id.x and id.y is within the placement map resolution range
    if (id.x < uint(_ChunkDimension) && id.y < uint(_ChunkDimension)) {
        // Load pixel data from placement map
        int pixelX = id.x + _ChunkDimension * _XOffset;
        int pixelY = id.y + _ChunkDimension * _YOffset;

        float4 pixel = _PlacementMap.Load(uint2(pixelX, pixelY));
        float4 black = float4(0.0, 0.0, 0.0, 1.0);

        // Initialize a grass data variable
        GrassData grass;

        // Check if the pixel is black
        if (pixel.r == black.r && pixel.g == black.g && pixel.b == black.b && pixel.a == black.a) {
            // Set the grass position
            float4 pos = 0.0f;

            float _scale = float(_Scale);
            float dimension = float(_TerrainDim);
            float chunkDimension = float(_ChunkDimension);
            float scaledDimension = dimension * _scale;

            pos.x = (id.x - (chunkDimension * 0.5f * _NumChunks)) + chunkDimension * _XOffset;
            pos.z = (id.y - (chunkDimension * 0.5f * _NumChunks)) + chunkDimension * _YOffset;
            pos.xz *= (1.0f / _scale);

            // Apply noise to the horizontal position coordinates of the grass
            // FYI: Tweak these values for more randomness
            pos.x += snoise(float3(pos.xz + _XOffset + _YOffset, 0.0f) * 3.0f) * 0.05f;
            pos.z += snoise(float3(pos.xz + _XOffset + _YOffset, 0.0f) * 4.0f) * 0.05f;

            // Calculate UV of grass
            float uvX = pos.x + dimension * 0.5f * _NumChunks * (1.0f / _NumChunks);
            float uvY = pos.z + dimension * 0.5f * _NumChunks * (1.0f / _NumChunks);

            float2 uv = float2(uvX, uvY) / dimension;
            uv.y = 1 - uv.y;
            uv.x = 1 - uv.x;

            float x = id.x + _ChunkDimension * _XOffset;
            float z = id.y + _ChunkDimension * _YOffset;

            x = scale(x, 0, _Resolution.x, 0, _HeightMapRes);
            z = scale(z, 0, _Resolution.y, 0, _HeightMapRes);

            float2 sIndex = float2(x,z);
            float4 displacement = 0.0f;

            if (_HeightMap[sIndex].r != black.r){
                displacement = _HeightMap[sIndex];
                pos.y = displacement.r * _MaxTerrainHeight * 2;
                _HeightMap[sIndex] = float4(1,0,0,1);
            }

            // Get a noise value based of the x and z coordinates
            float noise = abs(snoise(float3(pos.xz + _XOffset + _YOffset, 0.0f) * 2.2f));

            pos.w = lerp(0.3f, 0.8f, noise);

            // Apply calculated data to grass object
            grass.position = pos;
            grass.displacement = displacement.r * _MaxTerrainHeight * 2;
            grass.uv = uv;
            grass.placePosition = true;

            // Update grass in the buffer
            _GrassBuffer[id.x + id.y * _ChunkDimension] = grass;
        } else {
            grass.placePosition = false;
        }
    }
}
